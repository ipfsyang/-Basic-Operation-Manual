一、shell概述
自动化批量系统初始化程序 （update，软件安装，时区设置，安全策略...）
自动化批量软件部署程序（LAMP,LNMP,Tomcat,LVS,Nginx）
管理应用程序（KVM,集群管理扩容，MYSQL）
日志分析处理程序（PV,UV,200,!200,grep/awk,top 100）
自动化备份恢复程序。（mysql完全备份、增量备份+cron）
自动化管理程序（批量远程修改密码，软件升级配置更新）
自动化信息采集及监控程序（收集系统/应用状态信息，cpu，mem，disk，tcp status，net）
配合zabbix信息采集（收集系统/应用状态信息，cpu，mem，disk，tcp status，net）
自动化扩容（增加云主机————业务上线）
  zabbix监控CPU 80%+|-50% python api aws/ec2+shell script（业务上线）
shell可以做任何事（一切取决于业务需求）  
程序语言执行：
C 
JAVA
Shell
Python
程序是由哪些组成：逻辑+数据
 --------------------------------------------
 二、java python shell执行方式对比
 例：sudo vim shell01.sh
#!/bin/bash
ping -c 1 www.baidu.com &>/dev/null && echo "www.baidu.com successful" || echo "www.baidu.com failed!" //如能ping通的话返回successful值，失败则返回failed
&&：命令之间使用&&连接，实现逻辑与的功能只有在&&左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。  
||：命令之间使用||连接，实现逻辑或的功能，只有在||左边的命令返回假（命令返回值 ?==1），||右边的命令才会被执行。这和c语言中的逻辑或语法功能相同，即实现短路逻辑或操作。只要有一个命令返
回真（命令返回值? == 0），后面的命令就不会被执行。
&>：混合输出重定向，包括真确输出和错误输出
/dev/null：表示的是一个黑洞，通常用于丢弃不需要的数据输出，或者用于输入流的空文件
三、bash中调用python expect
#!/bin/bash
ping -c 1 www.baidu.com &>/dev/null && echo "www.baidu.com successful" || echo "www.baidu.com failed!" 这一段是shell语言

/usr/bin/python <<-EOF
print "HELLO WORLD"
EOF 这一段是python语言  <<-EOF是开始，结束语就应该用EOF来结束，这个可以变更的
四、login、nologin特性
在切换用户时，加-，才能执行/etc/profile和~/.bashrc
login shell su - alice 切换到root目录下
/etc/profile
/etc/bashrc  这两个是系统级

nologin shell su alice 不切换到root目录下
~/.etc/profile
~/.etc/bashrc 这两个是用户级
~/.bash_logout
~/.bash_history 
五、GNU/bash shell 特点
1.命令和文件自动补齐
2.命令历史记忆功能 !number、!staring、!$、!!、^R
3.别名功能 alias、unalias cp、~username/.bashrc、\cp -rf /etc/hosts
4.前后台作业控制 &、nohup、^c、^z、screen、bg %1、fg %1
5.输入输出重定向 0,1,2 > >> 2>> 2> 2>&1 &> cat < /etc/hosts cat<<EOF
root@ansible-10:~# cat <<EOF >file
> 111
> 222
> 333
> EOF
也可以这样输入
king@ansible-10:~$ cat >file <<EOF
> 111
> 222
> 333
> EOF
这都是输入到file文件里的
6.管道 |tee
7.分号；不具备逻辑判断，即使命令输入错误，他也会照常执行
8.&& ||具备逻辑判断 false=1返回值为假 true=0返回值为真
例:  ./configure && make && make install (命令返回值$?等于0就执行) //第一条命令执行成功，第二条命令才会执行。同样，第二条命令执行成功，第三条才会执行。
     mkdir /home/king/111/222 && echo 'ok...' //第一条命令执行不成功，第二条命令就不执行
     mkdir -p /home/king/111/222 && echo 'ok...' //第一条命令执行成功，第二条命令继续执行
     ls /home/king/111/222 || mkdir -p /home/king/111/222 (命令返回值$?不等0就执行)//第一条命令执行不成功，第二条命令也会执行
注意:command &  后台执行 
     command &> /dev/null 混合重定向（标准输出1，错误输出2）
     command1 && command2 命令排序，逻辑判断
9.shell通配符（元字符）
* 匹配多个字符
? 匹配一个字符
[] 匹配括号中任意一个字符 [abc] abc中的一个字母   
  [a-z]匹配a-z任意一个字符
  [0-9]匹配0-9任意一个字符
  [a-zA-Z0-9]匹配a-zA-Z0-9任意一个字符
  [^a-zA-Z0-9]括号中带有^字符，就是取反值，意思就是不匹配a-zA-Z0-9任意一个字符，而匹配的符号不如_ - +之类的。
() 在子shell中执行（cd /boot;ls）(umask 077;touch file100)
{} 集合touch file{1..9} //批量创建多个文件
    #mkdir /home/{111,222} mkdir -pv /home/{333/{aaa,bbb},444}
    #mkdir /home/king/{0..35} //连续创建多个目录 
    #rm -rf /home/king/{0..35} //连续删除多个目录 
    #cp -rv /ec/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfs-eth0.old
     cp -rv /ec/sysconfig/network-scripts/{ifcfg-eth0,ifcfg-eth0.old} //这是上一条命令的缩写（前面一部分是相同的）
     cp -rv /ec/sysconfig/network-scripts/ifcfg-eth0{,.lod} //这是上一条的缩写（，逗号隔开）
 \ 转义符，让元字符回归本意
    #echo *
    #echo \*  //打印*字符
    #touch ipfs\ sheng //创建两个文本 如果不加空格就会创建一个文本
    
    #mkdir \\
    echo -e "atb" //打印atb字母
    echo -e "a\tb" //输出a b字母这里的\t是tab的意思
    echo -e "a\nb" //输出a b字母这里的\n是换行的意思
 10.echo带颜色输出文本
\e[1;31m 红色字体 30--37是文本颜色，40-47是背景颜色
\e[0m表示重置颜色
例子： echo -e "\e[1;31mthis is test.txt \e[0m" //输出红色字体的this is test.txt，并重置文本颜色
      echo -e "\e[1;49m\e[1;30mthis is test.txt \e[0m" //也可以背景颜色和字体混合使用
      echo -e "\e[1;41mthis is test.txt" \e[0m"//输出红色背景的this is test.txt，并重置文本颜色
三、shell变量
  什么是shell变量？  变量的类型
  变量的定义方式
  变量的运算
  变量"内容"的删除和替换
  ping -c 1 $ip &>/dev/null && echo -e "$ip \e[1;31msuccessful \e[1;0m" || echo -e "$ip \e[1;31mfailed! \e[1;0m" 

  
  shell变量? 用一个特定的字符串去表示不固定的内容
  变量的类型：
    1.自定义变量
      定义变量：变量名=变量值 变量名必须以字母或下划线开头，区分大小写 例：ip=10.10.13.1格式
      引用变量：$变量名或$变量值
      查看变量：echo $变量名 set（所有变量：包括自定义变量和环境变量）
      取消变量：unset 变量名
      作用范围：仅在当前shell中有效
    2.环境变量
      定义环境变量:
         方法一：export back_dir2=/home/backup
         方法二：export back_dir将自定义变量转换成环境变量
      引用环境变量：$变量名或${变量值}
      查看环境变量：echo $变量名 env 例如：env |grep back_dir2
      取消环境变量：unset
      变量作用范围：在当前shell和子shell中有效
#!/bin/bash
ip=10.10.13.101
  if ping -c 1 $ip &>/dev/null;
  then
          echo -e "$ip \e[1;31msuccessful... \e[1;0m"
  else
          echo -e "$ip \e[1;31mfailed... \e[1;0m"
  fi











